name: "Task Manager API"
description: "A complete task/todo management backend"

server:
  host: "0.0.0.0"
  port: 3006

dashboard:
  enabled: true
  port: 3007

mode: "runtime"

endpoints:
  tasks:
    path: "/tasks"
    methods: ["GET", "POST"]
    description: "Task management"
    runtime:
      language: "javascript"
      handler: |
        function handler(req, res) {
          const tasks = [
            {
              id: 1,
              title: "Setup Backworks project",
              description: "Initialize a new API with YAML configuration and test basic functionality",
              status: "completed",
              priority: "high",
              due_date: "2025-06-20T17:00:00Z",
              created_at: "2025-06-19T09:00:00Z",
              completed_at: "2025-06-19T14:30:00Z",
              assigned_to: "john@example.com",
              assigned_name: "John Doe",
              tags: ["setup", "urgent"],
              estimated_hours: 4,
              actual_hours: 3.5
            },
            {
              id: 2,
              title: "Write API documentation",
              description: "Document all endpoints, request/response formats, and provide usage examples",
              status: "in_progress",
              priority: "medium",
              due_date: "2025-06-22T12:00:00Z",
              created_at: "2025-06-19T10:00:00Z",
              assigned_to: "jane@example.com",
              assigned_name: "Jane Smith",
              tags: ["documentation"],
              estimated_hours: 8,
              actual_hours: 2
            },
            {
              id: 3,
              title: "Add authentication",
              description: "Implement JWT token authentication with user registration and login",
              status: "pending",
              priority: "high",
              due_date: "2025-06-25T18:00:00Z",
              created_at: "2025-06-19T11:00:00Z",
              assigned_to: "john@example.com",
              assigned_name: "John Doe",
              tags: ["security", "authentication"],
              estimated_hours: 12,
              actual_hours: 0
            },
            {
              id: 4,
              title: "Database integration",
              description: "Connect API to PostgreSQL database for persistent data storage",
              status: "pending",
              priority: "medium",
              due_date: "2025-06-28T12:00:00Z",
              created_at: "2025-06-19T12:00:00Z",
              assigned_to: "jane@example.com",
              assigned_name: "Jane Smith",
              tags: ["database", "backend"],
              estimated_hours: 6,
              actual_hours: 0
            }
          ];
          
          if (req.method === 'GET') {
            let filteredTasks = tasks;
            
            // Filter by status
            const status = req.query_params?.status;
            if (status) {
              filteredTasks = filteredTasks.filter(t => t.status === status);
            }
            
            // Filter by priority
            const priority = req.query_params?.priority;
            if (priority) {
              filteredTasks = filteredTasks.filter(t => t.priority === priority);
            }
            
            // Filter by assignee
            const assignee = req.query_params?.assigned_to;
            if (assignee) {
              filteredTasks = filteredTasks.filter(t => t.assigned_to === assignee);
            }
            
            // Search in title and description
            const search = req.query_params?.search;
            if (search) {
              const searchLower = search.toLowerCase();
              filteredTasks = filteredTasks.filter(t => 
                t.title.toLowerCase().includes(searchLower) ||
                t.description.toLowerCase().includes(searchLower)
              );
            }
            
            // Pagination
            const page = parseInt(req.query_params?.page) || 1;
            const limit = parseInt(req.query_params?.limit) || 10;
            const offset = (page - 1) * limit;
            const paginatedTasks = filteredTasks.slice(offset, offset + limit);
            
            return {
              status: 200,
              body: {
                tasks: paginatedTasks,
                pagination: {
                  page: page,
                  limit: limit,
                  total: filteredTasks.length,
                  pages: Math.ceil(filteredTasks.length / limit)
                },
                summary: {
                  total: tasks.length,
                  completed: tasks.filter(t => t.status === 'completed').length,
                  in_progress: tasks.filter(t => t.status === 'in_progress').length,
                  pending: tasks.filter(t => t.status === 'pending').length
                }
              }
            };
          } else if (req.method === 'POST') {
            // Validation
            if (!req.body?.title) {
              return {
                status: 400,
                body: { 
                  error: 'Validation failed',
                  message: 'Title is required',
                  fields: ['title']
                }
              };
            }
            
            if (!req.body?.description) {
              return {
                status: 400,
                body: { 
                  error: 'Validation failed',
                  message: 'Description is required',
                  fields: ['description']
                }
              };
            }
            
            const validStatuses = ['pending', 'in_progress', 'completed'];
            if (req.body.status && !validStatuses.includes(req.body.status)) {
              return {
                status: 400,
                body: { 
                  error: 'Validation failed',
                  message: 'Status must be one of: ' + validStatuses.join(', '),
                  fields: ['status']
                }
              };
            }
            
            const validPriorities = ['low', 'medium', 'high', 'urgent'];
            if (req.body.priority && !validPriorities.includes(req.body.priority)) {
              return {
                status: 400,
                body: { 
                  error: 'Validation failed',
                  message: 'Priority must be one of: ' + validPriorities.join(', '),
                  fields: ['priority']
                }
              };
            }
            
            const newTask = {
              id: tasks.length + 1,
              title: req.body.title,
              description: req.body.description,
              status: req.body.status || 'pending',
              priority: req.body.priority || 'medium',
              due_date: req.body.due_date || null,
              created_at: new Date().toISOString(),
              assigned_to: req.body.assigned_to || null,
              assigned_name: req.body.assigned_name || null,
              tags: req.body.tags || [],
              estimated_hours: req.body.estimated_hours || 0,
              actual_hours: 0
            };
            
            return {
              status: 201,
              body: {
                message: 'Task created successfully',
                task: newTask
              }
            };
          }
        }
              status: "todo"
              priority: "high"
              due_date: "2025-06-25T15:00:00Z"
              created_at: "2025-06-19T11:00:00Z"
              assigned_to: "bob@example.com"
              tags: ["security", "auth"]
          summary:
            total: 3
            completed: 1
            in_progress: 1
  task_detail:
    path: "/tasks/{id}"
    methods: ["GET", "PUT", "DELETE"]
    description: "Individual task operations"
    runtime:
      language: "javascript"
      handler: |
        function handler(req, res) {
          const taskId = parseInt(req.path_params.id);
          
          // Mock task data with more details
          const task = {
            id: taskId,
            title: `Task ${taskId}: Setup Backworks project`,
            description: "Initialize a new API with YAML configuration file and test basic functionality to ensure everything works correctly.",
            status: taskId === 1 ? "completed" : (taskId === 2 ? "in_progress" : "pending"),
            priority: taskId <= 2 ? "high" : "medium",
            due_date: new Date(Date.now() + (taskId * 86400000)).toISOString(),
            created_at: new Date(Date.now() - (taskId * 3600000)).toISOString(),
            updated_at: new Date(Date.now() - (taskId * 1800000)).toISOString(),
            assigned_to: taskId % 2 === 1 ? "john@example.com" : "jane@example.com",
            assigned_name: taskId % 2 === 1 ? "John Doe" : "Jane Smith",
            tags: ["setup", "urgent"],
            estimated_hours: taskId * 2,
            actual_hours: taskId === 1 ? 3.5 : (taskId === 2 ? 1.5 : 0),
            completion_percentage: taskId === 1 ? 100 : (taskId === 2 ? 60 : 0),
            comments: [
              {
                id: 1,
                text: "Started working on this task",
                author: "john@example.com",
                author_name: "John Doe",
                created_at: new Date(Date.now() - 7200000).toISOString()
              },
              {
                id: 2,
                text: taskId === 1 ? "Completed successfully!" : "Making good progress",
                author: taskId % 2 === 1 ? "john@example.com" : "jane@example.com",
                author_name: taskId % 2 === 1 ? "John Doe" : "Jane Smith",
                created_at: new Date(Date.now() - 3600000).toISOString()
              }
            ]
          };
          
          if (req.method === 'GET') {
            return {
              status: 200,
              body: task
            };
          } else if (req.method === 'PUT') {
            if (!req.body) {
              return {
                status: 400,
                body: { error: 'Request body required' }
              };
            }
            
            const validStatuses = ['pending', 'in_progress', 'completed'];
            if (req.body.status && !validStatuses.includes(req.body.status)) {
              return {
                status: 400,
                body: { 
                  error: 'Invalid status',
                  message: 'Status must be one of: ' + validStatuses.join(', ')
                }
              };
            }
            
            const updatedTask = {
              ...task,
              title: req.body.title || task.title,
              description: req.body.description || task.description,
              status: req.body.status || task.status,
              priority: req.body.priority || task.priority,
              due_date: req.body.due_date || task.due_date,
              assigned_to: req.body.assigned_to || task.assigned_to,
              assigned_name: req.body.assigned_name || task.assigned_name,
              tags: req.body.tags || task.tags,
              estimated_hours: req.body.estimated_hours || task.estimated_hours,
              updated_at: new Date().toISOString()
            };
            
            // If status changed to completed, set completion time
            if (req.body.status === 'completed' && task.status !== 'completed') {
              updatedTask.completed_at = new Date().toISOString();
              updatedTask.completion_percentage = 100;
            }
            
            return {
              status: 200,
              body: {
                message: 'Task updated successfully',
                task: updatedTask,
                updated_fields: Object.keys(req.body)
              }
            };
          } else if (req.method === 'DELETE') {
            return {
              status: 204,
              body: null
            };
          }
        }

  complete_task:
    path: "/tasks/{id}/complete"
    methods: ["POST"]
    description: "Mark task as completed"
    runtime:
      language: "javascript"
      handler: |
        function handler(req, res) {
          const taskId = parseInt(req.path_params.id);
          
          return {
            status: 200,
            body: {
              message: 'Task marked as completed',
              task_id: taskId,
              completed_at: new Date().toISOString(),
              status: 'completed',
              completion_percentage: 100
            }
          };
        }

  users:
    path: "/users"
    methods: ["GET"]
    description: "Team members and their workload"
    runtime:
      language: "javascript"
      handler: |
        function handler(req, res) {
          const users = [
            {
              id: 1,
              email: "john@example.com",
              name: "John Doe",
              role: "Lead Developer",
              active_tasks: 3,
              completed_tasks: 12,
              workload: "medium",
              availability: "available",
              skills: ["rust", "api-design", "yaml"],
              join_date: "2024-01-15T00:00:00Z",
              avatar: "https://example.com/avatars/john.png"
            },
            {
              id: 2,
              email: "jane@example.com",
              name: "Jane Smith",
              role: "Documentation Lead",
              active_tasks: 2,
              completed_tasks: 8,
              workload: "light",
              availability: "available",
              skills: ["writing", "ui-ux", "testing"],
              join_date: "2024-03-20T00:00:00Z",
              avatar: "https://example.com/avatars/jane.png"
            },
            {
              id: 3,
              email: "bob@example.com",
              name: "Bob Wilson",
              role: "Security Engineer",
              active_tasks: 4,
              completed_tasks: 6,
              workload: "heavy",
              availability: "busy",
              skills: ["security", "auth", "devops"],
              join_date: "2024-02-10T00:00:00Z",
              avatar: "https://example.com/avatars/bob.png"
            }
          ];
          
          return {
            status: 200,
            body: {
              users: users,
              count: users.length,
              summary: {
                total_active_tasks: users.reduce((sum, u) => sum + u.active_tasks, 0),
                total_completed_tasks: users.reduce((sum, u) => sum + u.completed_tasks, 0),
                available_members: users.filter(u => u.availability === 'available').length
              }
            }
          };
        }

  user_tasks:
    path: "/users/{id}/tasks"
    methods: ["GET"]
    description: "Get tasks assigned to a specific user"
    runtime:
      language: "javascript"
      handler: |
        function handler(req, res) {
          const userId = parseInt(req.path_params.id);
          const userEmail = userId === 1 ? "john@example.com" : (userId === 2 ? "jane@example.com" : "bob@example.com");
          const userName = userId === 1 ? "John Doe" : (userId === 2 ? "Jane Smith" : "Bob Wilson");
          
          const userTasks = [
            {
              id: userId,
              title: `Task assigned to ${userName}`,
              description: `This task is specifically assigned to ${userName} for completion`,
              status: "in_progress",
              priority: "high",
              due_date: new Date(Date.now() + 86400000).toISOString(),
              created_at: new Date(Date.now() - 3600000).toISOString(),
              assigned_to: userEmail,
              assigned_name: userName,
              tags: ["user-specific"]
            },
            {
              id: userId + 10,
              title: `Secondary task for ${userName}`,
              description: `Another task in the queue for ${userName}`,
              status: "pending",
              priority: "medium",
              due_date: new Date(Date.now() + 172800000).toISOString(),
              created_at: new Date(Date.now() - 1800000).toISOString(),
              assigned_to: userEmail,
              assigned_name: userName,
              tags: ["secondary"]
            }
          ];
          
          return {
            status: 200,
            body: {
              user_id: userId,
              user_name: userName,
              user_email: userEmail,
              tasks: userTasks,
              task_count: userTasks.length,
              summary: {
                in_progress: userTasks.filter(t => t.status === 'in_progress').length,
                pending: userTasks.filter(t => t.status === 'pending').length,
                completed: userTasks.filter(t => t.status === 'completed').length
              }
            }
          };
        }
